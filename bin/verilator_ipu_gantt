#!/usr/bin/env python3

import argparse
import pathlib
import re
import numpy as np
import pandas as pd
import plotly.graph_objs as go
from plotly.subplots import make_subplots
import plotly.io as pio


if __name__ == "__main__":

    TRACE_BAR_WIDTH = 1
    DEFAULT_NUM_BINS = 10
    parser = argparse.ArgumentParser("plot IPU profile")
    parser.add_argument("obj_dir", metavar="OBJ_DIR", help="object directory (verilator output given by --Mdir)", default="obj_dir")
    parser.add_argument('-n', '--num', metavar="N", help="number of traces to show", default='5', type=int)

    args = parser.parse_args()

    objDir = pathlib.Path(args.obj_dir)

    def assertFileExists(dir: pathlib.Path):
        if not dir.exists():
            raise FileExistsError(f'File "{dir}" does not exist')

    postWorkloadPath = objDir / "postWorkload.txt"
    preExchangePath = objDir / "preExchange.txt"
    preWorkloadPath = objDir / "preWorkload.txt"
    estimatedPath = objDir / "estimatedCost.txt"
    assertFileExists(postWorkloadPath)
    assertFileExists(preExchangePath)
    assertFileExists(preWorkloadPath)
    assertFileExists(estimatedPath)


    # read the estimates
    estimatedCost = {}
    numTiles = 0
    with open(estimatedPath, 'r') as fp:
        pattern = r'__V.*__(?P<VERTEX>\d+)\s*@\s*\[\s*(?P<TILE>\d+),\s*(?P<WORKER>\d+)\s*\]\s*(?P<COST>\d+)'
        for line in fp.readlines():
            m = re.match(pattern, line)
            if m:
                t = int(m.group("TILE"))
                if t not in estimatedCost:
                    estimatedCost[t] = {
                        "vertex": [],
                        "worker": [],
                        "cost" : []
                    }
                v = int(m.group("VERTEX"))
                w = int(m.group("WORKER"))
                c = int(m.group("COST"))
                estimatedCost[t]['worker'].append(w)
                estimatedCost[t]['vertex'].append(v)
                estimatedCost[t]['cost'].append(c)

                numTiles = max(numTiles, t + 1)




    exchange = [[] for _ in range(numTiles)]
    workload = [[] for _ in range(numTiles)]

    with open(postWorkloadPath, 'r') as postfp, open(preExchangePath, 'r') as xfp, open(preWorkloadPath, 'r') as prefp:
        n = 0
        for (ex, pre, post) in zip(xfp.readlines(), prefp.readlines(), postfp.readlines()):
            if n >= args.num:
                break
            et = ex.split()
            pot = post.split()
            pret = pre.split()

            for tiles in range(numTiles):
                e0 = int(et[tiles])
                p0 = int(pret[tiles])
                p1 = int(pot[tiles])

                ed = (n, int(et[tiles]), p0 - e0)
                wd = (n, int(pret[tiles]), p1 - p0)
                exchange[tiles].append(ed)
                workload[tiles].append(wd)

            n += 1
    minTs = np.min([ts[0][1] for ts in exchange])

    # zero out the offset

    for tile in range(numTiles):
        exchange[tile] = [(n, s - minTs, d) for (n, s, d) in exchange[tile]]
        workload[tile] = [(n, s - minTs, d) for (n, s, d) in workload[tile]]


    def asDfRow(n, s, d, tile, t):
        return dict(N = n, Tile = tile, Start = s, Duration = d, Resource = t)

    fig = make_subplots(rows = 1, cols = 1)
    fig.update_layout(
        barmode='stack',
        template = "plotly_dark",
        xaxis ={'automargin': True},
        yaxis = {'automargin': True} #, 'categoryorder': 'category ascending'}}
    )

    def makeDf(data, label):
        df =  pd.DataFrame(
            [asDfRow(n, s, d, tile, label) for tile in range(numTiles) for (n, s, d) in data[tile]]
        )
        return df.sort_values(by = ["N", "Tile"])


    def plot(label: str, color: str, df: pd.DataFrame):

        traceDf = fig.add_bar(
            x = df["Duration"],
            y = df["Tile"],
            base = df["Start"],
            orientation = "h",
            showlegend=True,
            marker =  dict(color = color, line=dict(color=color, width = 2)),
            width = TRACE_BAR_WIDTH,
            name = label,
            customdata=df["Duration"],
            col = 1, row = 1
        )
        traceDf.update_traces(
            hovertemplate = "<br>".join(["start: %{base}", "tile: %{y}", 'delta: %{customdata}'])
        )

    exchange_df = makeDf(exchange, "Exchange")
    workload_df = makeDf(workload, "Workload")

    workloadAvg_df = pd.DataFrame([dict(Tile = tile, Delta = np.mean(df["Duration"])) for tile, df in workload_df.groupby("Tile")])
    workloadAvg_est = pd.DataFrame([dict(Tile = tile, Delta = np.max(estimatedCost[tile]['cost'])) for tile in range(numTiles)])

    plot("Exchange", "lightblue", exchange_df)
    plot("Workload", "tomato", workload_df)


    fig.update_xaxes(title = 'cycle')
    fig.update_yaxes(title = 'tile')


    TOMATOR_COLOR_PALE = "rgba(255, 99, 71, 0.5)"
    traceAvg = fig.add_bar(
        y = workloadAvg_df['Delta'],
        x = workloadAvg_df['Tile'],
        base = 0,
        orientation = 'v',
        marker = dict(color =TOMATOR_COLOR_PALE, line=dict(color='tomato', width = 2)),
        name = 'workload',
        showlegend = False,
        hovertemplate="<br>".join(["Delta:%{y}", "Tile:%{x}"]),
        row = 1, col = 1,
        visible=False,
    )
    # traceAvg.update_xaxes(title = 'tile')
    # traceAvg.update_yaxes(title = 'cycles')
    # print(workloadAvg_est)
    with open(objDir / "workloadDf.txt", 'w') as fp:
        fp.write(workload_df.to_string())
    with open(objDir / "exchangeDf.txt", 'w') as fp:
        fp.write(exchange_df.to_string())

    # plot estimated value
    error = [(real - est) / est * 100 for (est, real) in zip(workloadAvg_est['Delta'].tolist(), workloadAvg_df['Delta'].tolist())]

    print(f"Error stats (%):\n\tmean {np.mean(error):0.1f} std {np.std(error):0.1f} median {np.median(error):0.1f}\n\tmax {np.max(error):0.1f} min {np.min(error):0.1f}")
    worstAvgs = sorted(zip(workloadAvg_df['Delta'], workloadAvg_df['Tile']), key = lambda d: -d[0])
    print("Top 10 cycles:")
    for ((d, t), i) in zip(worstAvgs, range(10)):
        print(f"\tAt tile {t}: {d} ({np.max(estimatedCost[t]['cost'])})")
    print(f"Exchnage cycles: {np.max(exchange_df['Duration'])}")
    traceEst = fig.add_bar(
        y = workloadAvg_est['Delta'],
        x = workloadAvg_est['Tile'],
        base = 0,
        orientation= 'v',
        name = 'estimated',
        customdata=error,
        hovertemplate="<br>".join(["Delta:%{y}", "Tile:%{x}", "Error:%{customdata:.0f}%"]),
        # marker_alpha = 0.5,
        # marker = dict(color = 'none', pattern_shape='/', alpha=0.5),
        marker=dict(color='rgba(193, 255, 162, 0.5)', line=dict(color='rgba(0,0,0,0)', width=1), pattern_shape='/'),
        row = 1, col = 1,
        visible=False,
    )

    # traceEst.update_yaxes(
    #     title = 'cycles'
    # )
    # traceEst.update_xaxes(
    #     title = 'tiles'
    # )


    def plotHist(nbins: int = 5):
        traceHist = fig.add_histogram(
            x = workloadAvg_df['Delta'],
            name = 'histogram',
            nbinsx = nbins,
            row = 1, col = 1,
            visible=False,
        )

    binRange = range(1, len(workloadAvg_df['Delta'] + 1))
    # binsSlider = widgets.IntSlider(
    #     value=20,
    #     min=1,
    #     max=len(workloadAvg_df['Delta']),
    #     step=10,
    #     description='Number of Bins:',
    #     continuous_update=False
    # )

    # interactivePlot = widgets.interactive(plotHist, nbins=binsSlider)

    plotHist(DEFAULT_NUM_BINS)

    fig.update_layout(
        updatemenus=[
            {
                "buttons": [
                    {
                        "args": [
                            {"visible": [True, True, False, False, False]},
                            {
                                'xaxis' : {'title' : 'cycle'},
                                'yaxis' : {'title' : 'tile'},
                                'sliders': []
                            }
                        ], # Show first subplot, hide second
                        "label": "Trace",
                        "method": "update",

                    },
                    {
                        "args": [
                            {"visible": [False, False, True, True, False]},
                            {
                                'xaxis' : {'title' : 'tile'},
                                'yaxis' : {'title' : 'cycles'},
                                'sliders': []
                            }
                        ],
                        "label": "Average",
                        "method": "update",
                    },
                    {
                        "args": [
                            {"visible": [False, False, False, False, True]},
                            {
                                'xaxis' : {'title' : 'bins'},
                                'yaxis' : {'title' : 'cycles'},
                                'sliders' : [
                                    {
                                        'active': DEFAULT_NUM_BINS - 1, #default value,
                                        'yanchor': 'top',
                                        'xanchor': 'left',
                                        'currentvalue': {
                                            'prefix': 'Number of bins: ',
                                            'visible': True,
                                            'xanchor': 'right',
                                            'value': 20,
                                        },
                                        'transition': {'duration': 300, 'easing': 'cubic-in-out'},
                                        # 'pad': {'b': 10, 't': 50},
                                        # 'len': 0.9,
                                        # 'x': 0.1,
                                        # 'y': 0,
                                        'steps': [{
                                            'args': [
                                                        { 'nbinsx': int(i), "visible": [False, False, False, False, True]}
                                                    ],
                                            'label': str(i),
                                            'value': i,
                                            'method': 'update'
                                        } for i in binRange] # You can change the range as needed
                                    }
                                ]
                            },
                        ],
                        "label": "Histogram",
                        "method": "update",
                    }
                ],
                "direction": "down",
                "showactive": True,
            }
        ]

    )
    # display(interactivePlot)

    fig.show(renderer='browser')


