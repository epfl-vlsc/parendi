#!/usr/bin/env python3

import argparse
import pathlib
import re
import numpy as np
import pandas as pd
import plotly.graph_objs as go
from plotly.subplots import make_subplots
import plotly.io as pio


if __name__ == "__main__":

    TRACE_BAR_WIDTH = 1
    DEFAULT_NUM_BINS = 10
    IPU_TILES = 1472
    parser = argparse.ArgumentParser("plot IPU profile")
    parser.add_argument("obj_dir", metavar="OBJ_DIR", help="object directory (verilator output given by --Mdir)", default="obj_dir")
    parser.add_argument('-n', '--num', metavar="N", help="number of traces to show", default='5', type=int)
    parser.add_argument('-t', '--theme', metavar="THEME", help="plotly theme", default="plotly_white", type=str)
    parser.add_argument('-o', '--output', metavar="FILES", help="output images", nargs="+", type=pathlib.Path, default=list())
    parser.add_argument('-b', '--nbins', default=DEFAULT_NUM_BINS, help="number of bins in the histogram", type=int)
    parser.add_argument('-i', '--interactive', action='store_true', help="Bring up the plot interactively")

    args = parser.parse_args()

    objDir = pathlib.Path(args.obj_dir)

    def assertFileExists(dir: pathlib.Path):
        if not dir.exists():
            raise FileExistsError(f'File "{dir}" does not exist')

    postWorkloadPath = objDir / "postWorkload.txt"
    preExchangePath = objDir / "preExchange.txt"
    preWorkloadPath = objDir / "preWorkload.txt"
    estimatedPath = objDir / "estimatedCost.txt"
    initTsPath  = objDir / "initTs.txt"
    exchangeDumpPath = objDir / "exchangeDump.txt"

    assertFileExists(postWorkloadPath)
    assertFileExists(preExchangePath)
    assertFileExists(preWorkloadPath)
    assertFileExists(estimatedPath)


    # read the estimates


    estimatedCost = pd.read_table(estimatedPath, delim_whitespace=True)

    exchangeTable = pd.read_table(exchangeDumpPath, delim_whitespace=True)

    def tileCost(t: int):
        return np.max(estimatedCost.loc[estimatedCost['Tile'] == t]['Cycles'])

    numTiles = np.max(estimatedCost['Tile']) + 1
    numIpus = int(numTiles / IPU_TILES) + 1

    print(f"Tiles used: {numTiles} in {numIpus} IPUs")

    exchange = [[] for _ in range(numTiles)]
    workload = [[] for _ in range(numTiles)]
    exchangeMapSend = np.zeros((numTiles, numTiles))

    totalBytes = 0
    for _,row in exchangeTable.iterrows():
        stile = row['SourceTile']
        ttile = row['TargetTile']
        b = row['Bytes']
        exchangeMapSend[ttile, stile] += b
        totalBytes += b


    # Read the synchronized timestamps, they will serve as an offset that is subtracted from the other time stamps
    # We do this to essentially to counter the time shift across multiple IPUs
    initTs = []
    with open(initTsPath, 'r') as fp:
        initTs = [int(x) for x in fp.readlines()[0].strip().split(' ')]


    with open(postWorkloadPath, 'r') as postfp, open(preExchangePath, 'r') as xfp, open(preWorkloadPath, 'r') as prefp:
        n = 0
        for (ex, pre, post) in zip(xfp.readlines(), prefp.readlines(), postfp.readlines()):
            if n >= args.num:
                break
            et = ex.split()
            pot = post.split()
            pret = pre.split()

            for tiles in range(numTiles):
                offset = initTs[tiles]
                e0 = int(et[tiles]) - offset
                p0 = int(pret[tiles]) - offset
                p1 = int(pot[tiles]) - offset

                ed = (n, e0, p0 - e0)
                wd = (n, p0, p1 - p0)
                exchange[tiles].append(ed)
                workload[tiles].append(wd)

            n += 1

    minTs = np.min([e[0][1] for e in exchange])

    # zero out the offset

    for tile in range(numTiles):
        exchange[tile] = [(n, s - minTs, d) for (n, s, d) in exchange[tile]]
        workload[tile] = [(n, s - minTs, d) for (n, s, d) in workload[tile]]


    def asDfRow(n, s, d, tile, t):
        return dict(N = n, Tile = tile, Start = s, Duration = d, Resource = t)

    fig = make_subplots(rows = 1, cols = 1)
    fig.update_layout(
        barmode='stack',
        template = args.theme,
        xaxis ={'automargin': True},
        yaxis = {'automargin': True} #, 'categoryorder': 'category ascending'}}
    )

    def makeDf(data, label):
        df =  pd.DataFrame(
            [asDfRow(n, s, d, tile, label) for tile in range(numTiles) for (n, s, d) in data[tile]]
        )
        return df.sort_values(by = ["N", "Tile"])


    def plot(label: str, color: str, df: pd.DataFrame):

        traceDf = fig.add_bar(
            x = df["Duration"],
            y = df["Tile"],
            base = df["Start"],
            orientation = "h",
            showlegend=True,
            marker =  dict(color = color, line=dict(color=color, width = 2)),
            width = TRACE_BAR_WIDTH,
            name = label,
            customdata=df["Duration"],
            col = 1, row = 1
        )
        traceDf.update_traces(
            hovertemplate = "<br>".join(["start: %{base}", "tile: %{y}", 'delta: %{customdata}'])
        )

    exchange_df = makeDf(exchange, "Exchange")
    workload_df = makeDf(workload, "Workload")

    workloadAvg_df = pd.DataFrame([dict(Tile = tile, Delta = np.mean(df["Duration"])) for tile, df in workload_df.groupby("Tile")])
    workloadAvg_est = pd.DataFrame([dict(Tile = tile, Delta = tileCost(tile)) for tile in range(numTiles)])

    plot("Exchange", "lightblue", exchange_df)
    plot("Workload", "tomato", workload_df)
    fig.update_xaxes(title = 'cycle')
    fig.update_yaxes(title = 'tile')

    def saveImages(suffix):
        for oname in args.output:
            outwidth = 3.5
            dpi = 300
            aspectR = (16, 9)
            outFile = pathlib.Path(oname)
            outPath = outFile.parent / ((outFile.stem + "_" + suffix) + outFile.suffix)
            fig.write_image(outPath, width=outwidth * dpi, height=outwidth * dpi * aspectR[1] / aspectR[0], scale = 1)

    saveImages("trace")

    TOMATOR_COLOR_PALE = "rgba(255, 99, 71, 0.5)"
    traceAvg = fig.add_bar(
        y = workloadAvg_df['Delta'],
        x = workloadAvg_df['Tile'],
        base = 0,
        orientation = 'v',
        marker = dict(color =TOMATOR_COLOR_PALE, line=dict(color='tomato', width = 2)),
        name = 'workload',
        showlegend = False,
        hovertemplate="<br>".join(["Delta:%{y}", "Tile:%{x}"]),
        width = TRACE_BAR_WIDTH,
        row = 1, col = 1,
        visible=False,
    )
    # traceAvg.update_xaxes(title = 'tile')
    # traceAvg.update_yaxes(title = 'cycles')
    # print(workloadAvg_est)
    with open(objDir / "workloadDf.txt", 'w') as fp:
        fp.write(workload_df.to_string())
    with open(objDir / "exchangeDf.txt", 'w') as fp:
        fp.write(exchange_df.to_string())

    # plot estimated value
    error = [(real - est) / est * 100 for (est, real) in zip(workloadAvg_est['Delta'].tolist(), workloadAvg_df['Delta'].tolist())]

    print(f"Error stats (%):\n\tmean {np.mean(error):0.1f} std {np.std(error):0.1f} median {np.median(error):0.1f}\n\tmax {np.max(error):0.1f} min {np.min(error):0.1f}")
    worstAvgs = sorted(zip(workloadAvg_df['Delta'], workloadAvg_df['Tile']), key = lambda d: -d[0])
    print("Top 10 stragglers:")
    for ((d, t), i) in zip(worstAvgs, range(10)):
        print(f"\tAt tile {t}: {d} ({tileCost(t)})")
    def prettyBytes(b: int):
        if (b < (1 << 10)):
            return f"{b:.1f} B"
        elif (b < (1 << 20)):
            return f"{b / 1024: 0.1f} KiB"
        elif (b < (1 << 30)):
            return f"{b / 1024 / 1024: .1f} MiB"
        else:
            return f"{b / 1024 / 1024 / 1024: .1f} GiB"
    totalExchangeCycle = np.max(exchange_df['Duration'])
    bytesPerCycle = totalBytes / totalExchangeCycle
    print(f"Exchange:\n\tcycles {totalExchangeCycle}\n\tbytes {prettyBytes(totalBytes)}\n\tbw {prettyBytes(bytesPerCycle)}/c {prettyBytes(bytesPerCycle * 1.35e9)}/s")

    exchangeMapSendDevice = np.zeros((numIpus, numIpus))
    for sid in range(numTiles):
        for tid in range(numTiles):
            sIpu = int(sid / IPU_TILES)
            tIpu = int(tid / IPU_TILES)
            exchangeMapSendDevice[tIpu, sIpu] += exchangeMapSend[tid, sid]
    print("External exchnage:")
    for sIpu in range(numIpus):
        for tIpu in range(numIpus):
            print(f"\tIPU{sIpu}->IPU{tIpu} {prettyBytes(exchangeMapSendDevice[tIpu, sIpu])}")

    traceEst = fig.add_bar(
        y = workloadAvg_est['Delta'],
        x = workloadAvg_est['Tile'],
        base = 0,
        orientation= 'v',
        name = 'estimated',
        customdata=error,
        hovertemplate="<br>".join(["Delta:%{y}", "Tile:%{x}", "Error:%{customdata:.0f}%"]),
        # marker_alpha = 0.5,
        # marker = dict(color = 'none', pattern_shape='/', alpha=0.5),
        marker=dict(color='rgba(193, 255, 162, 0.5)', line=dict(color='rgba(0,0,0,0)', width=1), pattern_shape='/'),
        row = 1, col = 1,
        visible=False,
    )

    saveImages("average")
    # traceEst.update_yaxes(
    #     title = 'cycles'
    # )
    # traceEst.update_xaxes(
    #     title = 'tiles'
    # )


    def plotHist(df, label, marker):
        fig.add_histogram(
            x = df['Delta'],
            name = label,
            nbinsx = args.nbins,
            marker = marker,
            row = 1, col = 1,
            visible=False,
        )

    binRange = range(1, len(workloadAvg_df['Delta'] + 1))
    # binsSlider = widgets.IntSlider(
    #     value=20,
    #     min=1,
    #     max=len(workloadAvg_df['Delta']),
    #     step=10,
    #     description='Number of Bins:',
    #     continuous_update=False
    # )

    # interactivePlot = widgets.interactive(plotHist, nbins=binsSlider)

    plotHist(workloadAvg_df, "measured", marker=dict(color=TOMATOR_COLOR_PALE, line=dict(color='tomato', width=1), pattern_shape=''),)
    plotHist(workloadAvg_est, "estimated", marker=dict(color='rgba(193, 255, 162, 0.5)', line=dict(color='rgba(0,0,0,0)', width=1), pattern_shape='/'),)



    saveImages("hist")
    # def stepArg(i: int):
    #     c, b = np.histogram(workloadAvg_df['Delta'], bins=i)
    #     return {
    #         'x': b,
    #         'y': c,
    #         'visible': [False, False, False, False, True, True]
    #     }
    def ecdf(d):
        x = np.sort(d)
        def result(v):
            return np.searchsorted(x, v, side='right') / x.size
        return result

    def plotECDF(norm: bool):
        x = np.sort(workloadAvg_df['Delta'])
        ux = np.unique(x)
        y = np.searchsorted(x, ux, side = 'right') / (x.size if norm else 1)
        fig.add_scatter(x = y, y = ux, name='cdf', visible=False, marker_color="tomato")


    plotECDF(True)


    fig.add_heatmap(z = exchangeMapSend,
                    visible = False, name = "exchange", autocolorscale = True,
                    hovertemplate = "<br>".join(["txTile:%{x}", "rxTile:%{y}", "bytes:%{z}"]))

    exchangeRx = [sum(exchangeMapSend[r, :]) for r in range(numTiles)]
    exchangeTx = [sum(exchangeMapSend[:, t]) for t in range(numTiles)]

    fig.add_bar(
        y = exchangeRx,
        x = np.arange(numTiles),
        base = 0,
        orientation= 'v',
        name = 'RX',
        hovertemplate="<br>".join(["RX:%{y}", "Tile:%{x}"]),
        marker = dict(color =TOMATOR_COLOR_PALE, line=dict(color='tomato', width = 2)),
        row = 1, col = 1,
        visible=False,
    )

    FORESTGREEN_PALE = "rgba(34,139,34, 0.5)"
    fig.add_bar(
        y = exchangeTx,
        x = np.arange(numTiles),
        base = 0,
        orientation= 'v',
        name = 'TX',
        hovertemplate="<br>".join(["TX:%{y}", "Tile:%{x}"]),
        marker=dict(color=FORESTGREEN_PALE, line=dict(color='forestgreen', width=2)),
        row = 1, col = 1,
        visible=False,
    )


    fig.update_layout(
        updatemenus=[
            {
                "buttons": [
                    {
                        "args": [
                            {"visible": [True, True, False, False, False, False, False, False, False, False]},
                            {
                                'xaxis' : {'title' : 'cycle'},
                                'yaxis' : {'title' : 'tile'},
                                'sliders': []
                            }
                        ], # Show first subplot, hide second
                        "label": "Trace",
                        "method": "update",

                    },
                    {
                        "args": [
                            {"visible": [False, False, True, True, False, False, False, False, False, False]},
                            {
                                'xaxis' : {'title' : 'tile'},
                                'yaxis' : {'title' : 'cycles'},
                                'sliders': []
                            }
                        ],
                        "label": "Average",
                        "method": "update",
                    },
                    {
                        "args": [
                            {"visible": [False, False, False, False, True, True, False, False, False, False]},
                            {
                                'xaxis' : {'title' : 'cycles'},
                                'yaxis' : {'title' : 'count'},
                                'sliders' : [
                                    {
                                        'active': DEFAULT_NUM_BINS - 1, #default value,
                                        'yanchor': 'top',
                                        'xanchor': 'left',
                                        'currentvalue': {
                                            'prefix': 'Number of bins: ',
                                            'visible': True,
                                            'xanchor': 'right',
                                            'value': 20,
                                        },
                                        'transition': {'duration': 300, 'easing': 'cubic-in-out'},
                                        # 'pad': {'b': 10, 't': 50},
                                        # 'len': 0.9,
                                        # 'x': 0.1,
                                        # 'y': 0,
                                        'steps': [{
                                            'args': [
                                                        { 'nbinsx': int(i), "visible": [False, False, False, False, True, True, False, False, False]}
                                                    ],
                                            'label': str(i),
                                            'value': i,
                                            'method': 'update'
                                        } for i in binRange] # You can change the range as needed
                                    }
                                ]
                            },
                        ],
                        "label": "Histogram",
                        "method": "update",
                    },
                    {
                        "args": [
                            {"visible": [False, False, False, False, False, False, True, False, False, False]},
                            {
                                'xaxis' : {'title' : '$P$'},
                                'yaxis' : {'title' : 'cycles'},
                                'sliders': []
                            }
                        ],
                        "label": "CDF",
                        "method": "update",
                    },
                    {
                        "args": [
                            {"visible": [False, False, False, False, False, False, False, True, False, False]},
                            {
                                'xaxis' : {'title' : 'tx tile'},
                                'yaxis' : {'title' : 'tx tile'},
                                'sliders': []
                            }
                        ],
                        "label": "Heat",
                        "method": "update",
                    },
                    {
                        "args": [
                            {"visible": [False, False, False, False, False, False, False, False, True, True]},
                            {
                                'xaxis' : {'title' : 'tile'},
                                'yaxis' : {'title' : 'bytes'},
                                'sliders': []
                            }
                        ],
                        "label": "Exchange",
                        "method": "update",
                    }
                ],
                "direction": "down",
                "showactive": True,
            }
        ]

    )

    # display(interactivePlot)
    if args.interactive:
        fig.show()
    fig.write_html(objDir / "profile.html")



